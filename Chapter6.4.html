<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>6.4 Application architectures</title>
    <link href="./src/output.css" rel="stylesheet" />
  </head>

  <body>
    <header>
      <center>
        <h1><a href="homepage.html">CHAPTER 6</a></h1>
        <h2>Architectural Design</h2>
        <button><a href="chapter_6-1.html">Chapter 6.1</a></button>
        <button><a href="6.2.html">Chapter 6.2</a></button>
        <button><a href="Chapter6_3.html">Chapter 6.3</a></button>
        <button><a href="Chapter6.4.html">Chapter 6.4</a></button>
      </center>
    </header>

    <div id=" info1">
      <section>
        <h2>Application architectures</h2>

        <article>
          Application systems are intended to meet a business or organizational
          need. All business <br />
          have much in common—they need to hire people, issue invoices, keep
          <br />
          accounts, and so on. Businesses operating in the same sector use
          common sector <br />
          specific applications. Therefore, as well as general business
          functions, all phone <br />
          companies need systems to connect calls, manage their network, issue
          bills to <br />
          customers, etc. Consequently, the application systems used by these
          businesses also <br />
          have much in common. <br />
          These commonalities have led to the development of software
          architectures <br />
          that describe the structure and organization of particular types of
          software sys <br />
          tems. Application architectures encapsulate the principal
          characteristics of a <br />
          class of systems. For example, in real-time systems, there might be
          generic archi <br />
          tectural models of different system types, such as data collection
          systems or <br />
          monitoring systems. Although instances of these systems differ in
          detail, the <br />
          common architectural structure can be reused when developing new
          systems of <br />
          the same type. <br />
          The application architecture may be re-implemented when developing new
          <br />
          systems but, for many business systems, application reuse is possible
          without re- <br />
          implementation. We see this in the growth of Enterprise Resource
          Planning (ERP) <br />
          systems from companies such as SAP and Oracle, and vertical software
          packages <br />
          (COTS) for specialized applications in different areas of business. In
          these systems, <br />
          a generic system is configured and adapted to create a specific
          business application. <br />
        </article>
        <br />

        <article>
          <p>
            <img src="src/assets/img/mouse (2).png" alt="" />
            <a> Application architectures </a> <br />
            There are several examples of application architectures on the
            book’s website. These include descriptions of
            <br />
            batch data-processing systems, resource allocation systems, and
            event-based editing systems. <br />

            <a
              href="http://www.SoftwareEngineering-9.com/Web/Architecture/AppArch/"
            >
              <b
                >http://www.SoftwareEngineering-9.com/Web/Architecture/AppArch/</b
              ></a
            >
          </p>
        </article>

        <article>
          <p>
            For example, a system for supply chain management can be adapted for
            different <br />
            types of suppliers, goods, and contractual arrangements. <br />
            As a software designer, you can use models of application
            architectures in a num <br />
            ber of ways: <br />
          </p>

          <p>
            1. As a starting point for the architectural design process If you
            are unfamiliar with <br />
            the type of application that you are developing, you can base your
            initial design <br />
            on a generic application architecture. Of course, this will have to
            be specialized <br />
            for the specific system being developed, but it is a good starting
            point for design. <br />
            2. As a design checklist If you have developed an architectural
            design for an appli <br />
            cation system, you can compare this with the generic application
            architecture. <br />
            You can check that your design is consistent with the generic
            architecture. <br />
            3. As a way of organizing the work of the development team The
            application archi <br />
            tectures identify stable structural features of the system
            architectures and in <br />
            many cases, it is possible to develop these in parallel. You can
            assign work to <br />
            group members to implement different components within the
            architecture. <br />
            4. As a means of assessing components for reuse If you have
            components you <br />
            might be able to reuse, you can compare these with the generic
            structures to see <br />
            whether there are comparable components in the application
            architecture. <br />
            5. As a vocabulary for talking about types of applications If you
            are discussing a spe <br />
            cific application or trying to compare applications of the same
            types, then you can <br />
            use the concepts identified in the generic architecture to talk
            about the applications. <br />
          </p>

          <p>
            There are many types of application system and, in some cases, they
            may seem to <br />
            be very different. However, many of these superficially dissimilar
            applications actu <br />
            ally have much in common, and thus can be represented by a single
            abstract applica <br />
            tion architecture. We illustrate this here by describing the
            following architectures of <br />
            two types of application: <br />
          </p>
          1. Transaction processing applications Transaction processing
          applications are <br />
          database-centered applications that process user requests for
          information and <br />
          update the information in a database. These are the most common type
          of inter <br />
          active business systems. They are organized in such a way that user
          actions can’t <br />
          interfere with each other and the integrity of the database is
          maintained. This <br />

          <img src="src/assets/img/ggg.jpg" alt="" /> <br />

          class of system includes interactive banking systems, e-commerce
          systems, <br />
          information systems, and booking systems. <br />
          2. Language processing systems Language processing systems are systems
          in <br />
          which the user’s intentions are expressed in a formal language (such
          as Java). <br />
          The language processing system processes this language into an
          internal format <br />
          and then interprets this internal representation. The best-known
          language pro <br />
          cessing systems are compilers, which translate high-level language
          programs <br />
          into machine code. However, language processing systems are also used
          to <br />
          interpret command languages for databases and information systems, and
          <br />
          markup languages such as XML (Harold and Means, 2002; Hunter et al.,
          2007). <br />
          We have chosen these particular types of system because a large number
          of web <br />
          based business systems are transaction-processing systems, and all
          software devel <br />
          opment relies on language processing systems. <br />
        </article>
      </section>
    </div>

    <section>
      <div id="6.4.1 Transaction processing systems"></div>
      <h2>6.4.1 Transaction processing systems</h2>

      <article>
        Transaction processing (TP) systems are designed to process user
        requests for infor <br />
        mation from a database, or requests to update a database (Lewis et al.,
        2003). <br />
        Technically, a database transaction is sequence of operations that is
        treated as a sin <br />
        gle unit (an atomic unit). All of the operations in a transaction have
        to be completed <br />
        before the database changes are made permanent. This ensures that
        failure of opera <br />
        tions within the transaction does not lead to inconsistencies in the
        database. <br />
        From a user perspective, a transaction is any coherent sequence of
        operations that <br />
        satisfies a goal, such as ‘find the times of flights from London to
        Paris’. If the user <br />
        transaction does not require the database to be changed then it may not
        be necessary <br />
        to package this as a technical database transaction. <br />
        An example of a transaction is a customer request to withdraw money from
        a bank <br />
        account using an ATM. This involves getting details of the customer’s
        account, check <br />
        ing the balance, modifying the balance by the amount withdrawn, and
        sending com <br />
        mands to the ATM to deliver the cash. Until all of these steps have been
        completed, the <br />
        transaction is incomplete and the customer accounts database is not
        changed. <br />
        Transaction processing systems are usually interactive systems in which
        users <br />
        make asynchronous requests for service. Figure 6.14 illustrates the
        conceptual ar <br />
        chitectural structure of TP applications. First a user makes a request
        to the system <br />
        through an I/O processing component. The request is processed by some
        application <br />
        specific logic. A transaction is created and passed to a transaction
        manager, which is <br />
        usually embedded in the database management system. After the
        transaction manager <br />
        <img src="src/assets/img/hhh.jpg" alt="" /> <br />

        has ensured that the transaction is properly completed, it signals to
        the application <br />
        that processing has finished. <br />
        Transaction processing systems may be organized as a ‘pipe and filter’
        architec <br />
        ture with system components responsible for input, processing, and
        output. For <br />
        example, consider a banking system that allows customers to query their
        accounts <br />
        and withdraw cash from an ATM. The system is composed of two cooperating
        soft <br />
        ware components—the ATM software and the account processing software in
        the <br />
        bank’s database server. The input and output components are implemented
        as soft <br />
        ware in the ATM and the processing component is part of the bank’s
        database server. <br />
        Figure 6.15 shows the architecture of this system, illustrating the
        functions of the <br />
        input, process, and output components. <br />
      </article>
    </section>
    <section>
      <div id="6.4.2 Information systems">
        <h2>6.4.2 Information systems</h2>

        <article>
          <p>
            All systems that involve interaction with a shared database can be
            considered to be <br />
            transaction-based information systems. An information system allows
            controlled <br />
            access to a large base of information, such as a library catalog, a
            flight timetable, or <br />
            the records of patients in a hospital. Increasingly, information
            systems are web-based <br />
            systems that are accessed through a web browser. <br />
            Figure 6.16 a very general model of an information system. The
            system is mod <br />
            eled using a layered approach (discussed in Section 6.3) where the
            top layer supports <br />
            the user interface and the bottom layer is the system database. The
            user communica <br />
            tions layer handles all input and output from the user interface,
            and the information <br />
            retrieval layer includes application-specific logic for accessing
            and updating the <br />
            database. As we shall see later, the layers in this model can map
            directly onto servers <br />
            in an Internet-based system. <br />
            As an example of an instantiation of this layered model, Figure 6.17
            shows the <br />
            architecture of the MHC-PMS. Recall that this system maintains and
            manages details <br />
            of patients who are consulting specialist doctors about mental
            health problems. We have <br />
          </p>
          <p>
            <img src="src/assets/img/iii.jpg" alt="" /> <br />
            added detail to each layer in the model by identifying the
            components that support <br />
            user communications and information retrieval and access:
          </p>
          <p>
            1. The top layer is responsible for implementing the user interface.
            In this case, the <br />
            UI has been implemented using a web browser. 2. The second layer
            provides the user interface functionality that is delivered <br />
            through the web browser. It includes components to allow users to
            log in to the <br />
            system and checking components that ensure that the operations they
            use are <br />
            allowed by their role. This layer includes form and menu management
            compo <br />
            nents that present information to users, and data validation
            components that <br />
            check information consistency. 3. The third layer implements the
            functionality of the system and provides compo <br />
            nents that implement system security, patient information creation
            and updating, <br />
            import and export of patient data from other databases, and report
            generators <br />
            that create management reports.
          </p>

          <img src="src/assets/img/bbb.jpg" alt="" />

          <p>
            4. Finally, the lowest layer, which is built using a commercial
            database manage <br />
            ment system, provides transaction management and persistent data
            storage. Information and resource management systems are now usually
            web-based systems <br />
            where the user interfaces are implemented using a web browser. For
            example, <br />
            e-commerce systems are Internet-based resource management systems
            that accept elec <br />
            tronic orders for goods or services and then arrange delivery of
            these goods or services <br />
            to the customer. In an e-commerce system, the application-specific
            layer includes addi <br />
            tional functionality supporting a ‘shopping cart’ in which users can
            place a number of <br />
            items in separate transactions, then pay for them all together in a
            single transaction. <br />
            The organization of servers in these systems usually reflects the
            four-layer <br />
            generic model presented in Figure 6.16. These systems are often
            implemented as <br />
            multi-tier client server/architectures, as discussed in Chapter 18:
            <br />
            1. The web server is responsible for all user communications, with
            the user inter <br />
            face implemented using a web browser; 2. The application server is
            responsible for implementing application-specific <br />
            logic as well as information storage and retrieval requests; 3. The
            database server moves information to and from the database and
            handles <br />
            transaction management. <br />
            Using multiple servers allows high throughput and makes it possible
            to handle <br />
            hundreds of transactions per minute. As demand increases, servers
            can be added at <br />
            each level to cope with the extra processing involved. <br />
          </p>
        </article>
      </div>
    </section>

    <section>
      <div id="6.4.3 Language processing systems">
        <h2>6.4.3 Language processing systems</h2>

        <article>
          Language processing systems translate a natural or artificial language
          into another <br />
          representation of that language and, for programming languages, may
          also execute <br />
          the resulting code. In software engineering, compilers translate an
          artificial program <br />
          ming language into machine code. Other language-processing systems may
          translate <br />
          an XML data description into commands to query a database or to an
          alternative <br />
          XML representation. Natural language processing systems may translate
          one natural <br />
          language to another e.g., French to Norwegian. <br />
          A possible architecture for a language processing system for a
          programming lan <br />
          guage is illustrated in Figure 6.18. The source language instructions
          define the pro <br />
          gram to be executed and a translator converts these into instructions
          for an abstract <br />
          machine. These instructions are then interpreted by another component
          that fetches <br />
          the instructions for execution and executes them using (if necessary)
          data from the <br />
          environment. The output of the process is the result of interpreting
          the instructions <br />
          on the input data. <br />

          <img src="src/assets/img/lll.jpg" alt="" />

          <img src="src/assets/img/mouse (2).png" alt="" />
          <a> References architectures </a> <br />
          <p>
            Reference architectures capture important features of system
            architectures in a domain. Essentially, theyinclude <br />
            everything that might be in an application architecture although, in
            reality, it is very unlikely that anyindividual <br />
            application would include all the features shown in a reference
            architecture. The main purpose of reference
            <br />
            architectures is to evaluate and compare design proposals, and to
            educate people about architectural <br />
            characteristics in that domain.
          </p>
          <p>
            <a
              href="http://www.SoftwareEngineering-9.com/Web/Architecture/RefArch.html"
            >
              <b
                >http://www.SoftwareEngineering-9.com/Web/Architecture/RefArch.html</b
              ></a
            >
          </p>

          <p>
            5. A semantic analyzer that uses information from the syntax tree
            and the symbol <br />
            table to check the semantic correctness of the input language text.
          </p>
          <p>
            6. A code generator that ‘walks’ the syntax tree and generates
            abstract machine code.
          </p>
          Other components might also be included which analyze and transform
          the syn <br />
          tax tree to improve efficiency and remove redundancy from the
          generated machine <br />
          code. In other types of language processing system, such as a natural
          language trans <br />
          lator, there will be additional components such as a dictionary, and
          the generated <br />
          code is actually the input text translated into another language.
          <br />
          There are alternative architectural patterns that may be used in a
          language pro <br />
          cessing system (Garlan and Shaw, 1993). Compilers can be implemented
          using a <br />
          composite of a repository and a pipe and filter model. In a compiler
          architecture, the <br />
          symbol table is a repository for shared data. The phases of lexical,
          syntactic, and <br />
          semantic analysis are organized sequentially, as shown in Figure 6.19,
          and commu <br />
          nicate through the shared symbol table. <br />
          This pipe and filter model of language compilation is effective in
          batch environ <br />
          ments where programs are compiled and executed without user
          interaction; for <br />
          example, in the translation of one XML document to another. It is less
          effective <br />
          when a compiler is integrated with other language processing tools
          such as a struc <br />
          tured editing system, an interactive debugger or a program
          prettyprinter. In this <br />
          situation, changes from one component need to be reflected immediately
          in other <br />
          components. It is better, therefore, to organize the system around a
          repository, as <br />
          shown in Figure 6.20. <br />
          This figure illustrates how a language processing system can be part
          of an integrated <br />
          set of programming support tools. In this example, the symbol table
          and syntax tree act <br />
          as a central information repository. Tools or tool fragments
          communicate through it. <br />
          Other information that is sometimes embedded in tools, such as the
          grammar definition <br />
          and the definition of the output format for the program, have been
          taken out of the tools <br />
          and put into the repository. Therefore, a syntax-directed editor can
          check that the syntax <br />
          of a program is correct as it is being typed and a prettyprinter can
          create listings of the <br />
          program in a format that is easy to read. <br />

          <img src="src/assets/img/ppp.jpg" alt="" />
        </article>
      </div>
    </section>

    <section>
      <article>
        <h2>Key Points</h2>
        <ul>
          <li>
            A software architecture is a description of how a software system is
            organized. Properties of a <br />
            system such as performance, security, and availability are
            influenced by the architecture used.
          </li>
          <br />
          <li>
            Architectural design decisions include decisions on the type of
            application, the distribution of
            <br />
            the system, the architectural styles to be used, and the ways in
            which the architecture should be
            <br />
            documented and evaluated.
          </li>
          <br />
          <li>
            Architectures may be documented from several different perspectives
            or views. Possible views <br />
            include a conceptual view, a logical view, a process view, a
            development view, and a physical view.
          </li>
          <br />
          <li>
            Architectural patterns are a means of reusing knowledge about
            generic system architectures. <br />
            They describe the architecture, explain when it may be used, and
            discuss its advantages and <br />
            disadvantages.
          </li>
          <br />
          <li>
            Commonly used architectural patterns include Model-View-Controller,
            Layered Architecture, <br />
            Repository, Client–server, and Pipe and Filter.
          </li>
          <br />
          <li>
            Generic models of application systems architectures help us
            understand the operation of <br />
            applications, compare applications of the same type, validate
            application system designs, and <br />
            assess large-scale components for reuse.
          </li>
          <br />
          <li>
            Transaction processing systems are interactive systems that allow
            information in a database to <br />
            be remotely accessed and modified by a number of users. Information
            systems and resource <br />
            management systems are examples of transaction processing systems.
          </li>
          <br />
          <li>
            Language processing systems are used to translate texts from one
            language into another and <br />
            to carry out the instructions specified in the input language. They
            include a translator and an <br />
            abstract machine that executes the generated language. <br />
          </li>
        </ul>
      </article>
    </section>

    <section>
      <h2>FURTHER READING</h2>

      <article>
        <p>
          Software Architecture: Perspectives on an Emerging Discipline. This
          was the first book on <br />
          software architecture and has a good discussion on different
          architectural styles. (M. Shaw and <br />
          D. Garlan, Prentice-Hall, 1996.)
        </p>
        Software Architecture in Practice, 2nd ed. This is a practical
        discussion of software architectures that
        <br />
        <p>
          does not oversell the benefits of architectural design. It provides a
          clear business rationale <br />
          explaining why architectures are important. (L. Bass, P. Clements and
          R. Kazman, Addison-Wesley, <br />
          2003.)
        </p>
        <p>
          ‘The Golden Age of Software Architecture’This paper surveys the
          development of software <br />
          architecture from its beginnings in the 1980s through to its current
          usage. There is little technical <br />
          content but it is an interesting historical overview. (M. Shaw and P.
          Clements, IEEE Software, <br />
          21 (2), March–April 2006.)
          <a href="http://dx.doi.org/10.1109/MS.2006.58"
            >http://dx.doi.org/10.1109/MS.2006.58</a
          >.
        </p>
        <p>
          Handbook of Software Architecture. This is a work in progress by Grady
          Booch, one of the <br />
          early evangelists for software architecture. He has been documenting
          the architectures of a range of <br />
          software systems so you can see reality rather than academic
          abstraction. Available on the Web and <br />
          intended to appear as a book.
          <a href="http://www.handbookofsoftwarearchitecture.com/"
            >http://www.handbookofsoftwarearchitecture.com/</a
          >.
        </p>
      </article>
    </section>

    <section>
      <h2>EXERCISES</h2>

      <article>
        <ol start="6">
          <li>
            1 When describing a system, explain why you may have to design the
            system architecture <br />
            before the requirements specification is complete.
          </li>
        </ol>
        <ol start="6">
          <li>
            2 You have been asked to prepare and deliver a presentation to a
            non-technical manager to <br />
            justify the hiring of a system architect for a new project. Write a
            list of bullet points setting out <br />
            the key points in your presentation. Naturally, you have to explain
            what is meant by system <br />
            architecture.
          </li>
        </ol>

        <ol start="6">
          <li>
            3 Explain why design conflicts might arise when designing an
            architecture for which <br />
            both availability and security requirements are the most important
            non-functional <br />
            requirements.
          </li>
        </ol>

        <ol start="6">
          <li>
            4 Draw diagrams showing a conceptual view and a process view of the
            architectures of the <br />
            following systems: <br />
            An automated ticket-issuing system used by passengers at a railway
            station. <br />
            A computer-controlled video conferencing system that allows video,
            audio, and computer data <br />
            to be visible to several participants at the same time. <br />
            A robot floor cleaner that is intended to clean relatively clear
            spaces such as corridors. The <br />
            cleaner must be able to sense walls and other obstructions.
          </li>
        </ol>

        <ol start="6">
          <li>
            5 Explain why you normally use several architectural patterns when
            designing the architecture <br />
            of a large system. Apart from the information about patterns that I
            have discussed in this <br />
            chapter, what additional information might be useful when designing
            large systems?
          </li>

          <li>
            6 Suggest an architecture for a system (such as iTunes) that is used
            to sell and distribute music
            <br />
            on the Internet. What architectural patterns are the basis for this
            architecture?
          </li>

          <li>
            7 Explain how you would use the reference model of CASE environments
            (available on the <br />
            book’s web pages) to compare the IDEs offered by different vendors
            of a programming <br />
            language such as Java.
          </li>

          <li>
            8 Using the generic model of a language processing system presented
            here, design the <br />
            architecture of a system that accepts natural language commands and
            translates these into <br />
            database queries in a language such as SQL.
          </li>

          <li>
            9 Using the basic model of an information system, as presented in
            Figure 6.16, suggest the <br />
            components that might be part of an information system that allows
            users to view information <br />
            about flights arriving and departing from a particular airport.
          </li>

          <li>
            10 Should there be a separate profession of ‘software architect’
            whose role is to work <br />
            independently with a customer to design the software system
            architecture? A separate <br />
            software company would then implement the system. What might be the
            difficulties of <br />
            establishing such a profession?
          </li>
        </ol>
      </article>
    </section>
  </body>

  <footer>
    <section>
      <h2>REFERENCES</h2>
      <article>
        Bass, L., Clements, P. and Kazman, R. (2003). Software Architecture in
        Practice, 2nd ed. Boston: <br />
        Addison-Wesley. Berczuk, S. P. and Appleton, B. (2002). Software
        Configuration Management Patterns: Effective <br />
        Teamwork, Practical Integration. Boston: Addison-Wesley. Booch, G.
        (2009). ‘Handbook of software architecture’. Web publication. <br />
        http://www.handbookofsoftwarearchitecture.com/. Bosch, J. (2000). Design
        and Use of Software Architectures. Harlow, UK: Addison-Wesley.
        Buschmann, F., Henney, K. and Schmidt, D. C. (2007a). Pattern-oriented
        Software Architecture <br />
        Volume 4: A Pattern Language for Distributed Computing. New York: John
        Wiley & Sons. Buschmann, F., Henney, K. and Schmidt, D. C. (2007b).
        Pattern-oriented Software Architecture <br />
        Volume 5: On Patterns and Pattern Languages. New York: John Wiley &
        Sons. Buschmann, F., Meunier, R., Rohnert, H. and Sommerlad, P. (1996).
        Pattern-oriented Software <br />
        Architecture Volume 1: A System of Patterns. New York: John Wiley & Sons
        Clements, P., Bachmann, F., Bass, L., Garlan, D., Ivers, J., Little, R.,
        Nord, R. and Stafford, J. (2002).
        <br />
        Documenting Software Architectures: Views and Beyond. Boston:
        Addison-Wesley. Coplien, J. H. and Harrison, N. B. (2004).
        Organizational Patterns of Agile Software Development. <br />
        Englewood Cliffs, NJ: Prentice Hall. Gamma, E., Helm, R., Johnson, R.
        and Vlissides, J. (1995). Design Patterns: Elements of Reusable <br />
        Object-Oriented Software. Reading, Mass.: Addison-Wesley. Garlan, D. and
        Shaw, M. (1993). ‘An introduction to software architecture’. Advances in
        Software <br />
        Engineering and Knowledge Engineering, 1 1–39. Harold, E. R. and Means,
        W. S. (2002). XML in a Nutshell. Sebastopol. Calif.: O‘Reilly.
        Hofmeister, C., Nord, R. and Soni, D. (2000). Applied Software
        Architecture. Boston: Addison <br />
        Wesley. Hunter, D., Rafter, J., Fawcett, J. and Van Der Vlist, E.
        (2007). Beginning XML, 4th ed. Indianapolis, <br />
        Ind.: Wrox Press. Kircher, M. and Jain, P. (2004). Pattern-Oriented
        Software Architecture Volume 3: Patterns for <br />
        Resource Management. New York: John Wiley & Sons. Krutchen, P. (1995).
        ‘The 4+1 view model of software architecture’. IEEE Software, 12 (6),
        42–50. Lange, C. F. J., Chaudron, M. R. V. and Muskens, J. (2006). ‘UML
        software description and <br />
        architecture description’. IEEE Software, 23 (2), 40–6. Lewis, P. M.,
        Bernstein, A. J. and Kifer, M. (2003). Databases and Transaction
        Processing: An <br />
        Application-oriented Approach. Boston: Addison-Wesley. Martin, D. and
        Sommerville, I. (2004). ‘Patterns of interaction: Linking
        ethnomethodology and <br />
        design’. ACM Trans. on Computer-Human Interaction, 11 (1), 59–89. Nii,
        H. P. (1986). ‘Blackboard systems, parts 1 and 2’. AI Magazine, 7 (3 and
        4), 38–53 and 62–9. Schmidt, D., Stal, M., Rohnert, H. and Buschmann, F.
        (2000). Pattern-Oriented Software <br />
        Architecture Volume 2: Patterns for Concurrent and Networked Objects.
        New York: John Wiley & <br />
        Sons.
        <p>
          Shaw, M. and Garlan, D. (1996). Software Architecture: Perspectives on
          an Emerging Discipline. Englewood Cliffs, NJ: Prentice Hall. <br />
          Usability group. (1998). ‘Usability patterns’. Web publication. <br />
          <a href="http://www.it.bton.ac.uk/cil/usability/patterns/"
            >http://www.it.bton.ac.uk/cil/usability/patterns/</a
          >.
        </p>
      </article>
    </section>
  </footer>
</html>
