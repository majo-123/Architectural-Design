<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>6.4 Application architectures</title>
    <link href="./src/output.css" rel="stylesheet">
</head>

<body>

    <header>
        <center>
            <h1><a href="homepage.html">CHAPTER 6</a></h1>
            <h2>Architectural Design</h2>
            <button><a href="chapter_6-1.html">Chapter 6.1</a></button>
            <button><a href="6.2.html">Chapter 6.2</a></button>
            <button><a href="Chapter6_3.html">Chapter 6.3</a></button>
            <button><a href="Chapter6.4.html">Chapter 6.4</a></button>
        </center>
    </header>

    <div id=" info1">
    <section>
        
        <h2>Application architectures</h2>

        <article>
            Application systems are intended to meet a business or organizational need. All business <br>
            have much in common—they need to hire people, issue invoices, keep <br>
            accounts, and so on. Businesses operating in the same sector use common sector <br>
            specific applications. Therefore, as well as general business functions, all phone <br>
            companies need systems to connect calls, manage their network, issue bills to <br>
            customers, etc. Consequently, the application systems used by these businesses also <br>
            have much in common. <br>
            These commonalities have led to the development of software architectures <br>
            that describe the structure and organization of particular types of software sys <br>
            tems. Application architectures encapsulate the principal characteristics of a <br>
            class of systems. For example, in real-time systems, there might be generic archi <br>
            tectural models of different system types, such as data collection systems or <br>
            monitoring systems. Although instances of these systems differ in detail, the <br>
            common architectural structure can be reused when developing new systems of <br>
            the same type. <br>
            The application architecture may be re-implemented when developing new <br>
            systems but, for many business systems, application reuse is possible without re- <br>
            implementation. We see this in the growth of Enterprise Resource Planning (ERP) <br>
            systems from companies such as SAP and Oracle, and vertical software packages <br>
            (COTS) for specialized applications in different areas of business. In these systems, <br>
            a generic system is configured and adapted to create a specific business application. <br>

        </article> <br>

        <article>
            <img src="src/assets/img/mouse (2).png" alt=""> <a> Application architectures </a> <br> </p>
            There are several examples of application architectures on the book’s website. These include descriptions of
            <br>
            batch data-processing systems, resource allocation systems, and event-based editing systems. <br> </p>

            <a href="http://www.SoftwareEngineering-9.com/Web/Architecture/AppArch/">
                <b>http://www.SoftwareEngineering-9.com/Web/Architecture/AppArch/</b></a> </p>

        </article>

        <article>
            For example, a system for supply chain management can be adapted for different <br>
            types of suppliers, goods, and contractual arrangements. <br>
            As a software designer, you can use models of application architectures in a num <br>
            ber of ways: <br> </p>

            1. As a starting point for the architectural design process If you are unfamiliar with <br>
            the type of application that you are developing, you can base your initial design <br>
            on a generic application architecture. Of course, this will have to be specialized <br>
            for the specific system being developed, but it is a good starting point for design. <br>
            2. As a design checklist If you have developed an architectural design for an appli <br>
            cation system, you can compare this with the generic application architecture. <br>
            You can check that your design is consistent with the generic architecture. <br>
            3. As a way of organizing the work of the development team The application archi <br>
            tectures identify stable structural features of the system architectures and in <br>
            many cases, it is possible to develop these in parallel. You can assign work to <br>
            group members to implement different components within the architecture. <br>
            4. As a means of assessing components for reuse If you have components you <br>
            might be able to reuse, you can compare these with the generic structures to see <br>
            whether there are comparable components in the application architecture. <br>
            5. As a vocabulary for talking about types of applications If you are discussing a spe <br>
            cific application or trying to compare applications of the same types, then you can <br>
            use the concepts identified in the generic architecture to talk about the applications. <br> </p>

            There are many types of application system and, in some cases, they may seem to <br>
            be very different. However, many of these superficially dissimilar applications actu <br>
            ally have much in common, and thus can be represented by a single abstract applica <br>
            tion architecture. We illustrate this here by describing the following architectures of <br>
            two types of application: <br> </p>
            1. Transaction processing applications Transaction processing applications are <br>
            database-centered applications that process user requests for information and <br>
            update the information in a database. These are the most common type of inter <br>
            active business systems. They are organized in such a way that user actions can’t <br>
            interfere with each other and the integrity of the database is maintained. This <br>

            <img src="src/assets/img/ggg.jpg" alt=""> <br>

            class of system includes interactive banking systems, e-commerce systems, <br>
            information systems, and booking systems. <br>
            2. Language processing systems Language processing systems are systems in <br>
            which the user’s intentions are expressed in a formal language (such as Java). <br>
            The language processing system processes this language into an internal format <br>
            and then interprets this internal representation. The best-known language pro <br>
            cessing systems are compilers, which translate high-level language programs <br>
            into machine code. However, language processing systems are also used to <br>
            interpret command languages for databases and information systems, and <br>
            markup languages such as XML (Harold and Means, 2002; Hunter et al., 2007). <br>
            We have chosen these particular types of system because a large number of web <br>
            based business systems are transaction-processing systems, and all software devel <br>
            opment relies on language processing systems. <br>

        </article>
        
    </section>
    </div>



    <section>
        <div id="6.4.1 Transaction processing systems"></div>
        <h2>6.4.1 Transaction processing systems</h2>

        <article>
            Transaction processing (TP) systems are designed to process user requests for infor <br>
            mation from a database, or requests to update a database (Lewis et al., 2003). <br>
            Technically, a database transaction is sequence of operations that is treated as a sin <br>
            gle unit (an atomic unit). All of the operations in a transaction have to be completed <br>
            before the database changes are made permanent. This ensures that failure of opera <br>
            tions within the transaction does not lead to inconsistencies in the database. <br>
            From a user perspective, a transaction is any coherent sequence of operations that <br>
            satisfies a goal, such as ‘find the times of flights from London to Paris’. If the user <br>
            transaction does not require the database to be changed then it may not be necessary <br>
            to package this as a technical database transaction. <br>
            An example of a transaction is a customer request to withdraw money from a bank <br>
            account using an ATM. This involves getting details of the customer’s account, check <br>
            ing the balance, modifying the balance by the amount withdrawn, and sending com <br>
            mands to the ATM to deliver the cash. Until all of these steps have been completed, the <br>
            transaction is incomplete and the customer accounts database is not changed. <br>
            Transaction processing systems are usually interactive systems in which users <br>
            make asynchronous requests for service. Figure 6.14 illustrates the conceptual ar <br>
            chitectural structure of TP applications. First a user makes a request to the system <br>
            through an I/O processing component. The request is processed by some application <br>
            specific logic. A transaction is created and passed to a transaction manager, which is <br>
            usually embedded in the database management system. After the transaction manager <br>
            <img src="src/assets/img/hhh.jpg" alt=""> <br>

            has ensured that the transaction is properly completed, it signals to the application <br>
            that processing has finished. <br>
            Transaction processing systems may be organized as a ‘pipe and filter’ architec <br>
            ture with system components responsible for input, processing, and output. For <br>
            example, consider a banking system that allows customers to query their accounts <br>
            and withdraw cash from an ATM. The system is composed of two cooperating soft <br>
            ware components—the ATM software and the account processing software in the <br>
            bank’s database server. The input and output components are implemented as soft <br>
            ware in the ATM and the processing component is part of the bank’s database server. <br>
            Figure 6.15 shows the architecture of this system, illustrating the functions of the <br>
            input, process, and output components. <br>

        </article>
        </div>
    </section>
    <section>
        <div id="6.4.2 Information systems">
        <h2>6.4.2 Information systems</h2>

        <article>
            All systems that involve interaction with a shared database can be considered to be <br>
            transaction-based information systems. An information system allows controlled <br>
            access to a large base of information, such as a library catalog, a flight timetable, or <br>
            the records of patients in a hospital. Increasingly, information systems are web-based <br>
            systems that are accessed through a web browser. <br>
            Figure 6.16 a very general model of an information system. The system is mod <br>
            eled using a layered approach (discussed in Section 6.3) where the top layer supports <br>
            the user interface and the bottom layer is the system database. The user communica <br>
            tions layer handles all input and output from the user interface, and the information <br>
            retrieval layer includes application-specific logic for accessing and updating the <br>
            database. As we shall see later, the layers in this model can map directly onto servers <br>
            in an Internet-based system. <br>
            As an example of an instantiation of this layered model, Figure 6.17 shows the <br>
            architecture of the MHC-PMS. Recall that this system maintains and manages details <br>
            of patients who are consulting specialist doctors about mental health problems. We have <br> </p>
            <img src="src/assets/img/iii.jpg" alt=""> <br>
            added detail to each layer in the model by identifying the components that support <br>
            user communications and information retrieval and access: </p>
            1. The top layer is responsible for implementing the user interface. In this case, the <br>
            UI has been implemented using a web browser. </p>
            2. The second layer provides the user interface functionality that is delivered <br>
            through the web browser. It includes components to allow users to log in to the <br>
            system and checking components that ensure that the operations they use are <br>
            allowed by their role. This layer includes form and menu management compo <br>
            nents that present information to users, and data validation components that <br>
            check information consistency. </p>
            3. The third layer implements the functionality of the system and provides compo <br>
            nents that implement system security, patient information creation and updating, <br>
            import and export of patient data from other databases, and report generators <br>
            that create management reports. </p>

            <img src="src/assets/img/bbb.jpg" alt=""> </p>

            4. Finally, the lowest layer, which is built using a commercial database manage <br>
            ment system, provides transaction management and persistent data storage. </p>
            Information and resource management systems are now usually web-based systems <br>
            where the user interfaces are implemented using a web browser. For example, <br>
            e-commerce systems are Internet-based resource management systems that accept elec <br>
            tronic orders for goods or services and then arrange delivery of these goods or services <br>
            to the customer. In an e-commerce system, the application-specific layer includes addi <br>
            tional functionality supporting a ‘shopping cart’ in which users can place a number of <br>
            items in separate transactions, then pay for them all together in a single transaction. <br>
            The organization of servers in these systems usually reflects the four-layer <br>
            generic model presented in Figure 6.16. These systems are often implemented as <br>
            multi-tier client server/architectures, as discussed in Chapter 18: <br> </p>
            1. The web server is responsible for all user communications, with the user inter <br>
            face implemented using a web browser; </p>
            2. The application server is responsible for implementing application-specific <br>
            logic as well as information storage and retrieval requests; </p>
            3. The database server moves information to and from the database and handles <br>
            transaction management. <br></p>
            Using multiple servers allows high throughput and makes it possible to handle <br>
            hundreds of transactions per minute. As demand increases, servers can be added at <br>
            each level to cope with the extra processing involved. <br>

        </article>
        </div>
    </section>

    <section>
        <div id="6.4.3 Language processing systems">
        <h2>6.4.3 Language processing systems</h2>

        <article>
            Language processing systems translate a natural or artificial language into another <br>
            representation of that language and, for programming languages, may also execute <br>
            the resulting code. In software engineering, compilers translate an artificial program <br>
            ming language into machine code. Other language-processing systems may translate <br>
            an XML data description into commands to query a database or to an alternative <br>
            XML representation. Natural language processing systems may translate one natural <br>
            language to another e.g., French to Norwegian. <br>
            A possible architecture for a language processing system for a programming lan <br>
            guage is illustrated in Figure 6.18. The source language instructions define the pro <br>
            gram to be executed and a translator converts these into instructions for an abstract <br>
            machine. These instructions are then interpreted by another component that fetches <br>
            the instructions for execution and executes them using (if necessary) data from the <br>
            environment. The output of the process is the result of interpreting the instructions <br>
            on the input data. <br>

            <img src="src/assets/img/lll.jpg" alt=""> </p>

            <img src="src/assets/img/mouse (2).png" alt=""> <a> References architectures </a> <br> </p>

            Reference architectures capture important features of system architectures in a domain. Essentially,
            theyinclude <br>
            everything that might be in an application architecture although, in reality, it is very unlikely that
            anyindividual <br>
            application would include all the features shown in a reference architecture. The main purpose of reference
            <br>
            architectures is to evaluate and compare design proposals, and to educate people about architectural <br>
            characteristics in that domain. </p>

            <a href="http://www.SoftwareEngineering-9.com/Web/Architecture/RefArch.html">
                <b>http://www.SoftwareEngineering-9.com/Web/Architecture/RefArch.html</b></a> </p>

            5. A semantic analyzer that uses information from the syntax tree and the symbol <br>
            table to check the semantic correctness of the input language text. </p>
            6. A code generator that ‘walks’ the syntax tree and generates abstract machine code. </p>
            Other components might also be included which analyze and transform the syn <br>
            tax tree to improve efficiency and remove redundancy from the generated machine <br>
            code. In other types of language processing system, such as a natural language trans <br>
            lator, there will be additional components such as a dictionary, and the generated <br>
            code is actually the input text translated into another language. <br>
            There are alternative architectural patterns that may be used in a language pro <br>
            cessing system (Garlan and Shaw, 1993). Compilers can be implemented using a <br>
            composite of a repository and a pipe and filter model. In a compiler architecture, the <br>
            symbol table is a repository for shared data. The phases of lexical, syntactic, and <br>
            semantic analysis are organized sequentially, as shown in Figure 6.19, and commu <br>
            nicate through the shared symbol table. <br>
            This pipe and filter model of language compilation is effective in batch environ <br>
            ments where programs are compiled and executed without user interaction; for <br>
            example, in the translation of one XML document to another. It is less effective <br>
            when a compiler is integrated with other language processing tools such as a struc <br>
            tured editing system, an interactive debugger or a program prettyprinter. In this <br>
            situation, changes from one component need to be reflected immediately in other <br>
            components. It is better, therefore, to organize the system around a repository, as <br>
            shown in Figure 6.20. <br>
            This figure illustrates how a language processing system can be part of an integrated <br>
            set of programming support tools. In this example, the symbol table and syntax tree act <br>
            as a central information repository. Tools or tool fragments communicate through it. <br>
            Other information that is sometimes embedded in tools, such as the grammar definition <br>
            and the definition of the output format for the program, have been taken out of the tools <br>
            and put into the repository. Therefore, a syntax-directed editor can check that the syntax <br>
            of a program is correct as it is being typed and a prettyprinter can create listings of the <br>
            program in a format that is easy to read. <br>

            <img src="src/assets/img/ppp.jpg" alt=""> </p>
            
        </article>

        </div>

    </section>

    <section>
        <article>
            <h2>Key Points</h2>
            <ul>
                <li>
                    A software architecture is a description of how a software system is organized. Properties of a <br>
                    system such as performance, security, and availability are influenced by the architecture used.
                </li> <br>
                <li>Architectural design decisions include decisions on the type of application, the distribution of
                    <br>
                    the system, the architectural styles to be used, and the ways in which the architecture should be
                    <br>
                    documented and evaluated.
                </li> <br>
                <li>Architectures may be documented from several different perspectives or views. Possible views <br>
                    include a conceptual view, a logical view, a process view, a development view, and a physical view.
                </li> <br>
                <li>Architectural patterns are a means of reusing knowledge about generic system architectures. <br>
                    They describe the architecture, explain when it may be used, and discuss its advantages and <br>
                    disadvantages. </li> <br>
                <li>Commonly used architectural patterns include Model-View-Controller, Layered Architecture, <br>
                    Repository, Client–server, and Pipe and Filter. </li> <br>
                <li>Generic models of application systems architectures help us understand the operation of <br>
                    applications, compare applications of the same type, validate application system designs, and <br>
                    assess large-scale components for reuse. </li> <br>
                <li>Transaction processing systems are interactive systems that allow information in a database to <br>
                    be remotely accessed and modified by a number of users. Information systems and resource <br>
                    management systems are examples of transaction processing systems. </li> <br>
                <li>Language processing systems are used to translate texts from one language into another and <br>
                    to carry out the instructions specified in the input language. They include a translator and an <br>
                    abstract machine that executes the generated language. <br>
                </li>
            </ul>

        </article>

    </section>

    <section>
        <h2>FURTHER READING</h2>

        <article>

            Software Architecture: Perspectives on an Emerging Discipline. This was the first book on <br>
            software architecture and has a good discussion on different architectural styles. (M. Shaw and <br>
            D. Garlan, Prentice-Hall, 1996.) </p>
            Software Architecture in Practice, 2nd ed. This is a practical discussion of software architectures that
            <br>
            does not oversell the benefits of architectural design. It provides a clear business rationale <br>
            explaining why architectures are important. (L. Bass, P. Clements and R. Kazman, Addison-Wesley, <br>
            2003.) </p>
            ‘The Golden Age of Software Architecture’This paper surveys the development of software <br>
            architecture from its beginnings in the 1980s through to its current usage. There is little technical <br>
            content but it is an interesting historical overview. (M. Shaw and P. Clements, IEEE Software, <br>
            21 (2), March–April 2006.) <a
                href="http://dx.doi.org/10.1109/MS.2006.58">http://dx.doi.org/10.1109/MS.2006.58</a>.</p>
            Handbook of Software Architecture. This is a work in progress by Grady Booch, one of the <br>
            early evangelists for software architecture. He has been documenting the architectures of a range of <br>
            software systems so you can see reality rather than academic abstraction. Available on the Web and <br>
            intended to appear as a book. <a
                href="http://www.handbookofsoftwarearchitecture.com/">http://www.handbookofsoftwarearchitecture.com/</a>.
            </p>

        </article>
    </section>

    <section>
        <h2> EXERCISES </h2>

        <article>
            <ol start="6">
                <li>1 When describing a system, explain why you may have to design the system architecture <br>
                    before the requirements specification is complete. </li>
            </ol>
            <ol start="6">
                <li>2 You have been asked to prepare and deliver a presentation to a non-technical manager to <br>
                    justify the hiring of a system architect for a new project. Write a list of bullet points setting
                    out <br>
                    the key points in your presentation. Naturally, you have to explain what is meant by system <br>
                    architecture.
            </ol>
            <ol start="6">
                <li>3 Explain why design conflicts might arise when designing an architecture for which <br>
                    both availability and security requirements are the most important non-functional <br>
                    requirements.
            </ol>
            <ol start="6">
                <li>4 Draw diagrams showing a conceptual view and a process view of the architectures of the <br>
                    following systems: <br> </p>
                    An automated ticket-issuing system used by passengers at a railway station. <br> </p>
                    A computer-controlled video conferencing system that allows video, audio, and computer data <br>
                    to be visible to several participants at the same time. <br> </p>
                    A robot floor cleaner that is intended to clean relatively clear spaces such as corridors. The <br>
                    cleaner must be able to sense walls and other obstructions. </p>
            </ol>

            <ol start="6">
                <li>5 Explain why you normally use several architectural patterns when designing the architecture <br>
                    of a large system. Apart from the information about patterns that I have discussed in this <br>
                    chapter, what additional information might be useful when designing large systems? </p>

                <li>6 Suggest an architecture for a system (such as iTunes) that is used to sell and distribute music
                    <br>
                    on the Internet. What architectural patterns are the basis for this architecture? </p>

                <li>7 Explain how you would use the reference model of CASE environments (available on the <br>
                    book’s web pages) to compare the IDEs offered by different vendors of a programming <br>
                    language such as Java. </p>

                <li>8 Using the generic model of a language processing system presented here, design the <br>
                    architecture of a system that accepts natural language commands and translates these into <br>
                    database queries in a language such as SQL. </p>

                <li>9 Using the basic model of an information system, as presented in Figure 6.16, suggest the <br>
                    components that might be part of an information system that allows users to view information <br>
                    about flights arriving and departing from a particular airport. </p>

                <li>10 Should there be a separate profession of ‘software architect’ whose role is to work <br>
                    independently with a customer to design the software system architecture? A separate <br>
                    software company would then implement the system. What might be the difficulties of <br>
                    establishing such a profession?
            </ol>

        </article>
    </section>

</body>

<footer>
    <section>
        <h2> REFERENCES</h2>
        <article>
            Bass, L., Clements, P. and Kazman, R. (2003). Software Architecture in Practice, 2nd ed. Boston: <br>
            Addison-Wesley. </p>
            Berczuk, S. P. and Appleton, B. (2002). Software Configuration Management Patterns: Effective <br>
            Teamwork, Practical Integration. Boston: Addison-Wesley. </p>
            Booch, G. (2009). ‘Handbook of software architecture’. Web publication. <br>
            http://www.handbookofsoftwarearchitecture.com/. </p>
            Bosch, J. (2000). Design and Use of Software Architectures. Harlow, UK: Addison-Wesley. </p>
            Buschmann, F., Henney, K. and Schmidt, D. C. (2007a). Pattern-oriented Software Architecture <br>
            Volume 4: A Pattern Language for Distributed Computing. New York: John Wiley & Sons. </p>
            Buschmann, F., Henney, K. and Schmidt, D. C. (2007b). Pattern-oriented Software Architecture <br>
            Volume 5: On Patterns and Pattern Languages. New York: John Wiley & Sons. </p>
            Buschmann, F., Meunier, R., Rohnert, H. and Sommerlad, P. (1996). Pattern-oriented Software <br>
            Architecture Volume 1: A System of Patterns. New York: John Wiley & Sons </p>
            Clements, P., Bachmann, F., Bass, L., Garlan, D., Ivers, J., Little, R., Nord, R. and Stafford, J. (2002).
            <br>
            Documenting Software Architectures: Views and Beyond. Boston: Addison-Wesley. </p>
            Coplien, J. H. and Harrison, N. B. (2004). Organizational Patterns of Agile Software Development. <br>
            Englewood Cliffs, NJ: Prentice Hall. </p>
            Gamma, E., Helm, R., Johnson, R. and Vlissides, J. (1995). Design Patterns: Elements of Reusable <br>
            Object-Oriented Software. Reading, Mass.: Addison-Wesley. </p>
            Garlan, D. and Shaw, M. (1993). ‘An introduction to software architecture’. Advances in Software <br>
            Engineering and Knowledge Engineering, 1 1–39. </p>
            Harold, E. R. and Means, W. S. (2002). XML in a Nutshell. Sebastopol. Calif.: O‘Reilly. </p>
            Hofmeister, C., Nord, R. and Soni, D. (2000). Applied Software Architecture. Boston: Addison <br>
            Wesley. </p>
            Hunter, D., Rafter, J., Fawcett, J. and Van Der Vlist, E. (2007). Beginning XML, 4th ed. Indianapolis, <br>
            Ind.: Wrox Press. </p>
            Kircher, M. and Jain, P. (2004). Pattern-Oriented Software Architecture Volume 3: Patterns for <br>
            Resource Management. New York: John Wiley & Sons. </p>
            Krutchen, P. (1995). ‘The 4+1 view model of software architecture’. IEEE Software, 12 (6), 42–50. </p>
            Lange, C. F. J., Chaudron, M. R. V. and Muskens, J. (2006). ‘UML software description and <br>
            architecture description’. IEEE Software, 23 (2), 40–6. </p>
            Lewis, P. M., Bernstein, A. J. and Kifer, M. (2003). Databases and Transaction Processing: An <br>
            Application-oriented Approach. Boston: Addison-Wesley. </p>
            Martin, D. and Sommerville, I. (2004). ‘Patterns of interaction: Linking ethnomethodology and <br>
            design’. ACM Trans. on Computer-Human Interaction, 11 (1), 59–89. </p>
            Nii, H. P. (1986). ‘Blackboard systems, parts 1 and 2’. AI Magazine, 7 (3 and 4), 38–53 and 62–9. </p>
            Schmidt, D., Stal, M., Rohnert, H. and Buschmann, F. (2000). Pattern-Oriented Software <br>
            Architecture Volume 2: Patterns for Concurrent and Networked Objects. New York: John Wiley & <br>
            Sons. <p> </p>
            Shaw, M. and Garlan, D. (1996). Software Architecture: Perspectives on an Emerging Discipline. </p>
            Englewood Cliffs, NJ: Prentice Hall. <br>
            Usability group. (1998). ‘Usability patterns’. Web publication. <br>
            <a
                href="http://www.it.bton.ac.uk/cil/usability/patterns/">http://www.it.bton.ac.uk/cil/usability/patterns/</a>.
            </p>


        </article>
    </section>
</footer>

</html>