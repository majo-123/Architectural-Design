<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <header>
        <center>
            <h1><a href="homepage.html">CHAPTER 6</a></h1>
            <h2>Architectural Design</h2>
            <button><a href="chapter_6-1.html">Chapter 6.1</a></button>
            <button><a href="6.2.html">Chapter 6.2</a></button>
            <button><a href="Chapter6_3.html">Chapter 6.3</a></button>
            <button><a href="Chapter6.4.html">Chapter 6.4</a></button>
        </center>
    </header>
    
    <main> <h1>  6.3 Architectural patterns</h1>
        <p>  The idea of patterns as a way of presenting, sharing, and reusing knowledge about
             software systems is now widely used. The trigger for this was the publication of a
             book on object-oriented design patterns (Gamma et al., 1995), which prompted the
             development of other types of pattern, such as patterns for organizational design
             (Coplien and Harrison, 2004), usability patterns (Usability Group, 1998), interaction
             (Martin and Sommerville, 2004), configuration management (Berczuk and  Appleton, 2002), and so on.<br></br>

             <p> <strong>Figure 6.3 </strong> The organization of the MVC</p>
     
              <img src="src/img6.3.jpeg " alt=" Figure 6.3 The organization of the MVC ">
              <br></br>
              Architectural patterns were proposed in the 1990s under
             the name ‘architectural styles’ (Shaw and Garlan, 1996), with a five-volume series of
             handbooks on pattern-oriented software architecture published between 1996 and 2007 (Buschmann et al., 1996; Buschmann et al., 2007a; Buschmann et al., 2007b; Kircher and Jain, 2004; Schmidt et al., 2000).<br></br>
             In this section, I introduce architectural patterns and briefly describe a selection
             of architectural patterns that are commonly used in different types of systems. For
             more information about patterns and their use, you should refer to published pattern
             handbooks. You can think of an architectural pattern as a stylized, abstract description of good
             practice, which has been tried and tested in different systems and environments. So,
             an architectural pattern should describe a system organization that has been success
             ful in previous systems. It should include information of when it is and is not appro
             priate to use that pattern, and the pattern’s strengths and weaknesses.<br></br>
             For example, Figure 6.2 describes the well-known Model-View-Controller pattern.
             This pattern is the basis of interaction management in many web-based systems. The
             stylized pattern description includes the pattern name, a brief description (with an
             associated graphical model), and an example of the type of system where the pattern
             is used (again, perhaps with a graphical model). You should also include information
             about when the pattern should be used and its advantages and disadvantages.
             Graphical models of the architecture associated with the MVC pattern are shown in
             Figures 6.3 and 6.4. These present the architecture from different views—Figure 6.3
             is a conceptual view and Figure 6.4 shows a possible run-time architecture when this
             pattern is used for interaction management in a web-based system.
             <br></br>
             In a short section of a general chapter, it is impossible to describe all of the
             generic patterns that can be used in software development. Rather, I present some
             selected examples of patterns that are widely used and which capture good architec
            tural design principles. I have included some further examples of generic architec
            tural patterns on the book’s web pages.

        </p>
        <p> <strong>Figure 6.4 </strong> Web application architecture using the MVC pattern</p>
        <img src="src/img 6.4.jpeg " alt=" Figure 6.4 Web application architecture using the MVC pattern">
        
        <h2>  6.3.1 Layered architecture</h2>
        <p>  The notions of separation and independence are fundamental to architectural design
             because they allow changes to be localized. The MVC pattern, shown in Figure 6.2,
             separates elements of a system, allowing them to change independently. For example, adding a new view or changing an existing view can be done without any
             changes to the underlying data in the model. The layered architecture pattern is
             another way of achieving separation and independence. This pattern is shown in
             Figure 6.5. Here, the system functionality is organized into separate layers, and each
             layer only relies on the facilities and services offered by the layer immediately
             beneath it. <br></br></p>

        <p> <strong>Figure 6.5 </strong> The layered architecture pattern</p>
          <img src="src/img 6.5.jpeg" alt="Figure 6.5 The layered architecture pattern">


        <p> This layered approach supports the incremental development of systems. As a
         layer is developed, some of the services provided by that layer may be made avail
        able to users. The architecture is also changeable and portable. So long as its inter
        face is unchanged, a layer can be replaced by another, equivalent layer. Furthermore,
         when layer interfaces change or new facilities are added to a layer, only the adjacent
         layer is affected. As layered systems localize machine dependencies in inner layers,
         this makes it easier to provide multi-platform implementations of an application system. Only the inner, machine-dependent layers need be re-implemented to take
         account of the facilities of a different operating system or database.</p> <br></br>

         <p> <strong>Figure 6.6 </strong> A generic layered architecture</p>
        <img src="src/img 6.6.jpeg" alt=" Figure 6.6 A generic layered architecture">

      <p>
        Figure 6.6 is an example of a layered architecture with four layers. The
        lowest layer includes system support software—typically database and
        operating system support. The next layer is the application layer that
        includes the components concerned with the application functionality and
        utility components that are used by other application components. The
        third layer is concerned with user interface management and providing
        user authentication and authorization, with the top layer providing user
        interface facilities. Of course, the number of layers is arbitrary. Any
        of the layers in Figure 6.6 could be split into two or more layers.

<br></br> 

<p> <strong>Figure 6.7 </strong> The architecture of the LIBSYS system</p>
<img src="src/img 6.7.jpeg" alt=" Figure 6.7 The architecture of the LIBSYS system">
<br></br>
Figure 6.7 is an example of how this layered architecture pattern can be applied to a
 library system called LIBSYS, which allows controlled electronic access to copyright
 material from a group of university libraries. This has a five-layer architecture, with the
 bottom layer being the individual databases in each library.
 You can see another example of the layered architecture pattern in Figure 6.17
 (found in Section 6.4). This shows the organization of the system for mental health
care (MHC-PMS) that I have discussed in earlier chapter</p><br></br>

<h2>  6.3.2 Repository architecture</h2>

<p>  The layered architecture and MVC patterns are examples of patterns where the view presented is the conceptual organization of a system. My next example, the Repository pattern (Figure 6.8), describes how a set of interacting components can
    share data.  The layered architecture and MVC patterns are examples of patterns where the view
    presented is the conceptual organization of a system. My next example, the Repository pattern (Figure 6.8), describes how a set of interacting components can share data. 

    <br></br>
     <p> <strong>Figure 6.8 </strong> Figure 6.8 The repository pattern</p>
    <img src="src/img 6.8.jpeg" alt="Figure 6.8 The repository pattern">
    The majority of systems that use large amounts of data are organized around a
 shared database or repository. This model is therefore suited to applications in which data is generated by one component and used by another. Examples of this type of
 system include command and control systems, management information systems,
 CAD systems, and interactive development environments for software. </p>
 

 <p>  <strong>Figure 6.9 </strong>  A repository architecture for an IDE</p>

 <img src="src/img 6.9.jpeg" alt="A repository architecture for an IDE"> 
 <br></br>
 Figure 6.9 is an illustration of a situation in which a repository might be used.
 This diagram shows an IDE that includes different tools to support model-driven
 development. The repository in this case might be a version-controlled environment
 (as discussed in Chapter 25) that keeps track of changes to software and allows roll
back to earlier versions.
 <br></br>
 Organizing tools around a repository is an efficient way to share large amounts of
 has been derived for AI systems, uses a ‘blackboard’ model that triggers com
ponents when particular data become available. This is appropriate when the form of
 the repository data is less well structured. Decisions about which tool to activate can
 only be made when the data has been analyzed. This model is introduced by Nii
 (1986). Bosch (2000) includes a good discussion of how this style relates to system
 quality attributes.</p>

      <h2>6.3.3 Client–server architecture</h2>
      <p>
        The repository pattern is concerned with the static structure of a
        system and does not show its run-time organization. My next example
        illustrates a very commonly used run-time organization for distributed
        systems. The Client–server pattern is described in Figure 6.10.
      </p>

 <p>  <strong>Figure 6.10 </strong>  Figure 6.10 The client–server pattern</p>
 <img src="src/img 6.10.jpeg" alt=" Figure 6.10 The client–server pattern">
 <p> A system that follows the client–server pattern is organized as a set of services
 and associated servers, and clients that access and use the services. The major com
ponents of this model are:
 <br></br>
<ol>
<li>  A set of servers that offer services to other components. Examples of servers
 include print servers that offer printing services, file servers that offer file man
agement services, and a compile server, which offers programming language
 compilation services.
 <li> A set of clients that call on the services offered by servers. There will normally
 be several instances of a client program executing concurrently on different
 computers.</li>
<li>A network that allows the clients to access these services. Most client–server
 systems are implemented as distributed systems, connected using Internet
 protocols.</li> 
</ol>
 Client–server architectures are usually thought of as distributed systems architec
tures but the logical model of independent services running on separate servers can
 be implemented on a single computer. Again, an important benefit is separation and
 independence. Services and servers can be changed without affecting other parts of
 the system. <br></br>
 Clients may have to know the names of the available servers and the services that
 they provide. However, servers do not need to know the identity of clients or how
 many clients are accessing their services. Clients access the services provided by a
 server through remote procedure calls using a request-reply protocol such as the http  protocol used in the WWW. </p>

 
 <p>  <strong>Figure 6.11 </strong>  A client— server architecture for a film library</p>
 <img src="src/img 6.11.jpeg" alt="Figure 6.11 A client— server architecture for a film library">
 <p> Essentially, a client makes a request to a server and
 waits until it receives a reply.
 Figure 6.11 is an example of a system that is based on the client–server model. This
 is a multi-user, web-based system for providing a film and photograph library. In this
 system, several servers manage and display the different types of media. Video frames
 need to be transmitted quickly and in synchrony but at relatively low resolution. They
 may be compressed in a store, so the video server can handle video compression and
 decompression in different formats. Still pictures, however, must be maintained at a
 high resolution, so it is appropriate to maintain them on a separate server.
  <br></br>
   The catalog must be able to deal with a variety of queries and provide links into
 the web information system that includes data about the film and video clips, and an
 e-commerce system that supports the sale of photographs, film, and video clips. </p>
 
  <p>  <strong>Figure 6.12 </strong>   The pipe and filter pattern</p>
 <img src="src/img 6.12.jpeg" alt=" Figure 6.12 The pipe and filter pattern">


  <p>  <strong>Figure 6.13 </strong> An example of the pipe and filter architecture</p>
 <img src="src/img 6.13.jpeg" alt=" Figure 6.13 An example of the pipe and filter architecture">

      <p>
        The client program is simply an integrated user interface, constructed
        using a web browser, to access these services. The most important
        advantage of the client–server model is that it is a distributed
        architecture. Effective use can be made of networked systems with many
        distributed processors. It is easy to add a new server and integrate it
        with the rest of the system or to upgrade servers transparently without
        affecting other parts of the system. I discuss distributed
        architectures, including client–server architectures and distrib uted
        object architectures, in Chapter 18.
      </p>

      <h2>6.3.4 Pipe and filter architecture</h2>
      <p>
        My final example of an architectural pattern is the pipe and filter
        pattern. This is a model of the run-time organization of a system where
        functional transformations process their inputs and produce outputs.
        Data flows from one to another and is trans formed as it moves through
        the sequence. Each processing step is implemented as a transform. Input
        data flows through these transforms until converted to output. The
        transformations may execute sequentially or in parallel. The data can be
        processed by each transform item by item or in a single batch.<br />
        The name ‘pipe and filter’ comes from the original Unix system where it
        was pos sible to link processes using ‘pipes’. These passed a text
        stream from one process to another. Systems that conform to this model
        can be implemented by combining Unix commands, using pipes and the
        control facilities of the Unix shell. The term ‘filter’ is used because
        a transformation ‘filters out’ the data it can process from its input
        data stream.<br />
        Variants of this pattern have been in use since computers were first
        used for auto matic data processing. When transformations are sequential
        with data processed in batches, this pipe and filter architectural model
        becomes a batch sequential model, a common architecture for data
        processing systems (e.g., a billing system). The archi tecture of an
        embedded system may also be organized as a process pipeline, with each
        process executing concurrently. I discuss the use of this pattern in
        embedded systems in Chapter 20.<br />
        An example of this type of system architecture, used in a batch
        processing appli cation, is shown in Figure 6.13. An organization has
        issued invoices to customers. Once a week, payments that have been made
        are reconciled with the invoices.
      </p>



 <p> <strong>Architectural patterns for control</strong> </p>
 There are specific architectural patterns that reflect commonly used ways of organizing control in a system.
 These include centralized control, based on one component calling other components, and event-based control,
 where the system reacts to external events. 
 <strong><a href="">http://www.SoftwareEngineering-9.com/Web/Architecture/ArchPatterns/</a></strong></p>

 <p> For those invoices that have been paid, a receipt is issued. For those invoices that have
 not been paid within the allowed payment time, a reminder is issued.<br></br>
 Interactive systems are difficult to write using the pipe and filter model because
 of the need for a stream of data to be processed. Although simple textual input
 and output can be modeled in this way, graphical user interfaces have more complex
 I/O formats and a control strategy that is based on events such as mouse clicks or
 menu selections. It is difficult to translate this into a form compatible with the
 pipelining model.</p>
</main>
    <footer> </footer>
</body>
</html>